import numpy as np
import lepm.lattice_elasticity as le
import lepm.plotting.plotting as leplt
import lepm.plotting.colormaps as lecmaps
import lepm.data_handling as dh
import lepm.stringformat as sf
import matplotlib.pyplot as plt
import matplotlib.path as mplpath
import sys
import copy
import argparse
import lepm.data_handling as dh

'''Functions for generating hyperuniform point sets with variable S(k) exponents (gamma)

kicksz : average of the log of kick sizes (zeta_i), so kicksz = np.sum(np.log10(zeta)) / float(nn)
epsilon : the parameter controlling the transformation from random variable in (0, 1) to kick size zeta

'''


def gammapts(gamma, nh, nv, epsilon=1e-9):
    """Create a square array of nn particles in a hyperuniform configuration, with the hyperuniformity exponent
    determined by the power gamma. If nn is not a square number, then the number of points is equal to int(sqrt(nn))**2.

    Parameters
    ----------
    gamma : float
        power of the kick distribution is -1-gamma
    nh : int
        number of rows in the lattice of pts
    nv : int
        number of cols in the lattice of pts
    aa : float
        minimum distance for the kick
    bb : float
        maximum distance for the kick


    Returns
    -------
    xy : n*m x 2 float array
        The points of the hyperuniform distribution
    """
    nn = nh * nv
    xy = np.array([[float(ii), float(jj)] for ii in range(nh) for jj in range(nv)])
    eta = np.random.rand(nn, 2)
    xy += eta
    zeta = gammapowerlaw_random(gamma, epsilon, size=2*len(xy)).reshape(len(xy), 2)
    print 'np.shape(zeta) = ', np.shape(zeta)
    xy += zeta
    # Enforce periodicity of the bounding box: put points that have left bbox back inside the box
    xy[:, 0] = np.mod(xy[:, 0], nh)
    xy[:, 1] = np.mod(xy[:, 1], nv)
    return xy


def gammapts_kicksz(gamma, nh, nv, kicksz=1., calibdata_dir='auto'):
    """

    Parameters
    ----------
    gamma
    nh
    nv
    kicksz : float
        average of the log of kick sizes (zeta_i), so kicksz = np.sum(np.log10(zeta)) / float(nn)
    calibdata_dir : str
        path to the calibration fitting data, for gkc.retrieve_epsilon()

    Returns
    -------
    xy
    eps
    """
    import lepm.build.pointsets.gammakick_calibration as gkc
    eps = gkc.retrieve_epsilon(kicksz, gamma, calibdata_dir=calibdata_dir)
    return gammapts(gamma, nh, nv, epsilon=eps), eps


def gammapts_boundedkick(gamma, nh, nv, aa=1., bb=20.):
    """Create a square array of nn particles in a hyperuniform configuration, with the hyperuniformity exponent
    determined by the power gamma. The kick size is bounded between aa and bb.
    This function assumes that the upper bound kick size is less than the system size.
    If nn is not a square number, then the number of points is equal to int(sqrt(nn))**2.

    Parameters
    ----------
    gamma : float
        power of the kick distribution is -1-gamma
    nh : int
        number of rows in the lattice of pts
    nv : int
        number of cols in the lattice of pts
    aa : float
        minimum distance for the kick
    bb : float
        maximum distance for the kick


    Returns
    -------
    xy : n*m x 2 float array
        The points of the hyperuniform distribution
    """
    nn = nh * nv
    xy = np.array([[float(ii), float(jj)] for ii in range(nh) for jj in range(nv)])
    eta = np.random.rand(nn, 2)
    xy += eta
    zeta = gammapowerlaw_random_bounded(gamma, aa, bb, size=2.*len(xy)).reshape(len(xy), 2)
    print 'np.shape(zeta) = ', np.shape(zeta)
    xy += zeta
    # Equate the x=0 line with x=mm and y=0 with y=mm
    left = np.where(xy[:, 0] < 0)[0]
    right = np.where(xy[:, 0] > 0)[0]
    top = np.where(xy[:, 1] > 0)[0]
    bottom = np.where(xy[:, 1] < 0)[0]
    xy[left, 0] += float(nh)
    xy[right, 0] -= float(nh)
    xy[top, 1] -= float(nv)
    xy[bottom, 1] += float(nv)
    return xy


def gammapowerlaw_random(gamma, eps, size=1):
    """Power-law gen for pdf(x) \propto x^{-gamma-1} for 0<=x<=infinity.
    The unbounded distribution is generated by coordinate transformation:
    x in (0, 1) --> y = eps x**(1/(-gamma)) * (1-x)
    --> y = eps * (1/x)**(1/(gamma)) * (1-x)
    For small x, this gives y ~ x**(-1/gamma), so dx/dy ~ y**(-1-gamma), as desired, since P(y) ~ dx/dy

    Parameters
    ----------
    gamma : float > 0
        positive value denoting exponent of S(k)
    aa : int
        Lower limit on the x value for pdf
    bb : int
        Upper limit on x value for pdf
    size : int
        The length of the array to be generated from powerlaw pdf
    """
    x = np.random.random(size=size)
    return eps * x ** (1./(-gamma)) * (1-x)


def gammapowerlaw_random_bounded(gamma, aa, bb, size=1):
    """Power-law gen for pdf(x) \propto x^{-gamma-1} for a<=x<=b

    Parameters
    ----------
    gamma : float > 0
        positive value denoting exponent of S(k)
    aa : int
        Lower limit on the x value for pdf
    bb : int
        Upper limit on x value for pdf
    size : int
        The length of the array to be generated from powerlaw pdf
    """
    r = np.random.random(size=size)
    ag, bg = aa**(-gamma), bb**(-gamma)
    return (ag + (bg - ag)*r)**(-1./gamma)


def gamma_pdf(x, a, b, gamma):
    """Probability distribution function with pdf(x) \propto x^{-gamma-1} for a<=x<=b"""
    ag, bg = a**(-gamma), b**(-gamma)
    return -gamma * x**(-gamma-1) / (bg - ag)


# THIS STUFF IS MOVED TO relax_pointsets.py
# def relax_overdamped(xy, pv, bbox, timesteps, dt, modout=10, outpath=None, save_im=False):
#     """Relax a system of particles by a central force, with velocity equal to Force.
#     For the interaction, use F=(1-r)rhat for r<1, where r is the distance between particles and rhat is the vector
#     between them.
#
#     Parameters
#     ----------
#     xy
#     PV
#     timesteps
#     dt
#     modout
#     outpath : str
#         the full path, except for the txt extension, to put the output files
#
#     Returns
#     -------
#
#     """
#     xyo = copy.deepcopy(xy)
#
#     # Check if the bbox is a rectangle aligned with the xy axes
#     isrect = (dh.unique_count(bbox[:, 0])[:, 1] > 1).all() and (dh.unique_count(bbox[:, 1])[:, 1] > 1).all()
#     if isrect:
#         minx = np.min(bbox[:, 0])
#         maxx = np.max(bbox[:, 0])
#         miny = np.min(bbox[:, 1])
#         maxy = np.max(bbox[:, 1])
#         # Since the bbox is a rectangle, we can assume one element of each of the periodic vectors is zero
#         # Form pvx, the distance in x of the periodic vector pointing in the x dir, and similarly for y
#         pvx = np.max(np.abs(pv[:, 0]))
#         pvy = np.max(np.abs(pv[:, 1]))
#
#     # Save initial positions if outpath is not None
#     ii = 0
#     time = 0.
#
#     if outpath is not None:
#         print 'saving to ', outpath + '{0:06d}'.format(ii)
#         header = 'Relaxing (spreading) xy pts generated by gammakick procedure: t={0:0.12e}'.format(time) +\
#                  ', dt={0:0.12e}'.format(dt)
#         np.savetxt(outpath + '{0:08.3f}'.format(time).replace('.', 'p') + '.txt', xy, header=header)
#     if save_im:
#         lecmaps.register_colormaps()
#         cmap = plt.get_cmap('viridis')
#
#     for ii in (np.arange(timesteps) + 1):
#         # Relax for a time dt
#         if ii % modout == 0:
#             print 'relaxing pts: ii=', ii
#         time += dt
#         dxy = spreading_forces(xyo, pv) * dt
#         xyo += dxy
#         if isrect:
#             # Since the bbox is a rectangle, we can just move the points outside the bounds back inside
#             xyo[xyo[:, 0] < minx, 0] += pvx
#             xyo[xyo[:, 1] < miny, 1] += pvy
#             xyo[xyo[:, 0] > maxx, 0] -= pvx
#             xyo[xyo[:, 1] > maxy, 1] -= pvy
#         else:
#             # The bbox is a more complicated shape, so we have to use something like matplotlib's inpoly
#             bpath = mplpath.Path(bbox)
#             outside = not bpath.contains_points(xy)
#             raise RuntimeError('Have not included functionality for non-rectangular periodic BCs. Build that here.')
#
#         if np.mod(ii, modout) == 0 and outpath is not None:
#             header = 'Relaxing (spreading) xy pts generated by gammakick procedure: t={0:0.12e}'.format(time) + \
#                      ', dt={0:0.12e}'.format(dt)
#             np.savetxt(outpath + '{0:08.3f}'.format(time).replace('.', 'p') + '.txt', xyo, header=header)
#         if save_im:
#             plt.scatter(xyo[:, 0], xyo[:, 1], c=cmap(float(ii)/float(timesteps)), edgecolor='none')
#     return xyo
#
#
# def spreading_forces(xy, pv, eps=1e-12, check=False):
#     """Compute force F=(1-r)rhat for r<1, where r is the distance between particles and rhat is the vector between them
#
#     Parameters
#     ----------
#     xy
#     pv
#
#     Returns
#     -------
#     forces
#     """
#     dists = le.dist_pts_periodic(xy, xy, pv, dim=-1, square_norm=False)
#     # print 'np.shape(dists) = ', np.shape(dists)
#     xdists = le.dist_pts_periodic(xy, xy, pv, dim=0)
#     ydists = le.dist_pts_periodic(xy, xy, pv, dim=1)
#     xdhat = np.nan_to_num(xdists / np.abs(dists))
#     ydhat = np.nan_to_num(ydists / np.abs(dists))
#     xforce = (1 - dists) * xdhat
#     yforce = (1 - dists) * ydhat
#     # print 'np.shape(xforce) = ', np.shape(xforce)
#     # find where distances are greater than eps and less than 1
#     mask = np.logical_and(dists > eps, dists < 1.0).astype(float)
#     # sum over each row to get the force on that particle
#     forces = np.zeros_like(xy, dtype=float)
#     if check:
#         le.plot_real_matrix(xdists, show=True, name='xdists')
#         le.plot_real_matrix(xdhat, show=True, name='xdhat')
#         le.plot_real_matrix(xforce, show=True, name='xforce')
#         le.plot_real_matrix(xforce * mask, show=True, name='xforce * mask')
#
#     # Note that it actually doesn't matter which axis we sum over, since the distance matrix is equal to its transpose
#     # If there is any repulsion, sum over repulsive forces in net forces
#     if len(np.nonzero(mask)) > 0:
#         forces[:, 0] = np.sum(xforce * mask, axis=1)
#         forces[:, 1] = np.sum(yforce * mask, axis=1)
#
#     return forces


if __name__ == "__main__":
    import lepm.dataio as dio
    import cPickle as pkl
    import glob
    import relax_pointset as relax
    '''Example usage:
    python ./build/pointsets/gammakick.py -make_pointset -N 3600
    python ./build/pointsets/gammakick.py -make_pointset -gamma 0.5 -NH 20 -NV 50 -conf 1:3 -save_im
    python ./build/pointsets/gammakick.py -make_pointset -gamma 1.60 -NH 100 -NV 150 -conf 1
    '''
    # Make new points with chosen gamma
    # check input arguments for timestamp (name of simulation is timestamp)
    parser = argparse.ArgumentParser(description='Specify time string (timestr) for gyro simulation.')
    parser.add_argument('-demo_hexnerpowerlaw', '--demo_hexnerpowerlaw',
                        help="demonstrate Daniel's method for the probability distribution function creation",
                        action='store_true')
    parser.add_argument('-demo_pdf_bounded', '--demo_pdf_bounded',
                        help="demonstrate the module's probability distribution function functionality",
                        action='store_true')
    parser.add_argument('-demo_spreading', '--demo_spreading',
                        help="demonstrate the module's hyperuniform point set spreading with time functionality",
                        action='store_true')
    parser.add_argument('-demo_gamma', '--demo_gamma',
                        help="demonstrate the module's hyperuniform point set creation functionality",
                        action='store_true')
    parser.add_argument('-calibrate_Sk_epsilon', '--calibrate_Sk_epsilon',
                        help="Calibrate the hyperuniformity vs amplitude of kick transformation, epsilon",
                        action='store_true')
    parser.add_argument('-calibrate_kicksz_epsilon', '--calibrate_kicksz_epsilon',
                        help="Calibrate the distance pts travel vs amplitude of epsilon parameter given to coord" +
                             "transformation",
                        action='store_true')
    parser.add_argument('-calibrate_epsilon_kicksz', '--calibrate_epsilon_kicksz',
                        help="Calibrate the correct parameter epsilon vs desired kick size",
                        action='store_true')
    parser.add_argument('-calibrate_Sk_kicksz', '--calibrate_Sk_kicksz',
                        help="Calibrate the hyperuniformity vs amplitude of kicks",
                        action='store_true')
    parser.add_argument('-calibration_check', '--calibration_check',
                        help="Check that the calibration is holding average kicksize constant",
                        action='store_true')

    parser.add_argument('-make_pointset', '--make_pointset', help="Create and save hyperuniform point set",
                        action='store_true')
    parser.add_argument('-save_im', '--save_im', help="Save images of the pointset as it relaxes",
                        action='store_true')
    parser.add_argument('-make_pointset_bounded', '--make_pointset_bounded',
                        help="Create and save hyperuniform point set with bounded amplitude kicks (NOT STANDARD)",
                        action='store_true')

    parser.add_argument('-rootdir', '--rootdir', help='The directory in which to save files', type=str,
                        default='/Users/npmitchell/Dropbox/Soft_Matter/GPU/networks/random_organization_source/' +
                                'random_kick_gamma_npm/')
    parser.add_argument('-gamma', '--gamma', help='Power for the hyperuniform point set', type=float, default=0.5)
    parser.add_argument('-kicksz', '--kicksz', help='Average log of kick size zeta for unbounded pdf based on transf.',
                        type=float, default=-1.5)
    parser.add_argument('-conf', '--conf',
                        help='Index of the configuration to make. Can be of the form 01:1:50, or '
                             '1/2/3/4/5, or other string formatable to an array',
                        type=str, default='01')
    parser.add_argument('-timesteps', '--timesteps',
                        help='Max number of timesteps for spreading to take place ',
                        type=int, default=1000)
    parser.add_argument('-dt', '--dt', help='Timestep for spreading relaxation', type=float, default=0.001)
    parser.add_argument('-N', '--N',
                        help='Mesh width AND height, in number of lattice spacings (leave blank to spec separate dims)',
                        type=int, default=-1)
    parser.add_argument('-NH', '--NH', help='Mesh width, in number of lattice spacings', type=int, default=20)
    parser.add_argument('-NV', '--NV', help='Mesh height, in number of lattice spacings', type=int, default=20)
    args = parser.parse_args()

    if args.N > 0:
        nh = args.N
        nv = args.N
    else:
        nh = args.NH
        nv = args.NV

    if args.demo_hexnerpowerlaw:
        epsv = np.array([1e-12, 1e-7])
        gammav = np.array([0.2, 0.5, 0.8])
        fig, ax = leplt.initialize_nxmpanel_fig(len(gammav), 1, wsfrac=0.6, hsfrac=0.3, fontsize=18, vspace=20,
                                                x0frac=0.1)
        kk = 0
        for gamma in gammav:
            for eps in epsv:
                y = gammapowerlaw_random(args.gamma, eps, size=5e6)
                vals, edges = np.histogram(y, bins=2e5)
                # bins=np.logspace(np.log10(np.min(y)), np.log10(np.max(y)), 50))
                ax[kk].loglog(edges[2:], vals[1:], '.', label=r'$\epsilon = $' + '{0:0.0e}'.format(eps))
                # expected curve : (y1/x1^gamma) = (y0/x0^gamma)
                xx = 0.1 * edges[2:]
                yy = vals[1] * (xx/xx[0]) ** (-1 - gamma)
                ax[kk].plot(xx, yy, 'k--')
            ax[kk].legend(loc='center left', bbox_to_anchor=(1.0, 0.5))
            ax[kk].set_title(r'$\gamma = $' + '{0:0.2f}'.format(gamma))
            ax[kk].set_ylim(ymin=0.5)
            kk += 1
        plt.suptitle('Coordinate transform: ' + r'$x \rightarrow \epsilon x^{\frac{1}{-1-\gamma}}(1-x)$')
        plt.savefig(args.rootdir + 'gamma_pdfs.png', dpi=300)
        plt.show()

    if args.demo_pdf_bounded:
        # Show that pdf works:
        gamma = 0.2
        a = 1.
        b = 3.
        xx = gammapowerlaw_random_bounded(gamma, a, b, size=10000)
        plt.hist(xx, bins=100, normed=True)
        xx = np.linspace(a, b, 100)
        plt.plot(xx, gamma_pdf(xx, a, b, gamma), 'm.-')
        plt.plot(xx, xx**(-gamma - 1.), 'k--', lw=5)
        plt.show()

    if args.demo_spreading:
        PV = np.array([[20, 0], [0, 20]])
        xx = np.arange(20.)
        yy = np.arange(20.)
        xyg = np.meshgrid(xx, yy)
        xy = np.dstack((xyg[0].ravel(), xyg[1].ravel()))[0]
        print 'np.random.rand(np.shape(xy)[0], np.shape(xy)[1]) = ', np.random.rand(np.shape(xy)[0], np.shape(xy)[1])
        xy += np.random.rand(np.shape(xy)[0], np.shape(xy)[1])
        print 'xy = ', xy
        plt.plot(xy[:, 0], xy[:, 1], 'b.')
        plt.title('xy pts before spreading')
        plt.show()
        forces = relax.spreading_forces(xy, PV, check=False)
        print 'forces = ', forces
        plt.plot(xy[:, 0], xy[:, 1], 'b.')
        plt.quiver(xy[:, 0], xy[:, 1], forces[:, 0], forces[:, 1], scale_units='width', scale=10)
        plt.show()

    if args.demo_gamma:
        dt = args.dt
        gamma = args.gamma
        xy = gammapts(gamma, 20, 20)
        # Check the initial points
        plt.plot(xy[:, 0], xy[:, 1], 'r.')
        plt.show()
        pv = np.array([[20, 0], [0, 20]])
        bbox = np.array([[0., 20.], [20., 20.], [20., 0.], [0., 0.]])
        xyout = relax.relax_overdamped(xy, pv, bbox, 100, dt, modout=10, outpath=None, save_im=True)
        plt.show()
        plt.plot(xy[:, 0], xy[:, 1], 'rx')
        plt.plot(xyout[:, 0], xyout[:, 1], 'b.')
        print 'xyout - xy = ', xyout - xy
        plt.show()

    if args.calibrate_Sk_epsilon:
        """Calibrate S(k) scaling versus epsilon"""
        import lepm.structure as struct

        nksteps = 200
        klim_frac = 0.1
        LL = (float(nh), float(nv))
        print 'LL = ', LL
        gammav = np.arange(0.1, 1., 0.2)
        epsv = [1e-15, 1e-11, 1e-7, 1e-3, 1., 10]
        colorv = lecmaps.husl_palette(len(epsv))

        # Naming
        seriesname = 'structure/nksteps{0:03d}'.format(nksteps) + '_sz{0:04d}'.format(nh) + '{0:04d}'.format(nv) + \
                     '_klim' + sf.float2pstr(klim_frac) + 'LL'
        caloutdir = args.rootdir + 'calibration/' + seriesname + '/'
        datoutdir = args.rootdir + 'calibration_data/' + seriesname + '/'
        dio.ensure_dir(caloutdir)
        dio.ensure_dir(datoutdir)

        kk = 0
        for gamma in gammav:
            kk = 0
            ymax = 0.
            fig, ax = leplt.initialize_1panel_fig(wsfrac=0.45, hsfrac=0.35, y0frac=0.14, x0frac=0.17)
            for eps in epsv:
                fn = datoutdir + 'gamma' + sf.float2pstr(gamma) + '_epsilon{0:0.0e}'.format(eps) + '.pkl'
                globfn = glob.glob(fn)
                if globfn:
                    with open(globfn[0], "r") as f:
                        datadict = pkl.load(f)
                    kr = datadict['kr']
                    Skr = datadict['Skr']
                else:
                    xy = gammapts(gamma, nh, nv, epsilon=eps)
                    kx, ky, Skmesh, kr, Skr = struct.calc_structure_factor(xy, LL, klim=klim_frac * LL[0],
                                                                           nksteps=nksteps)
                    datadict = {'kr': kr, 'Skr': Skr}
                    with open(fn, "w") as f:
                        pkl.dump(datadict, f)

                ax.loglog(kr, Skr, '.', color=colorv[kk], label=r'$\epsilon=$' + '{0:0.0e}'.format(eps),
                          markersize=2)
                ymax = max(np.nanmax(Skr), ymax)
                kk += 1

            xx = [kr[3], np.max(kr)]
            yy = [dh.nanmedian(Skr), (np.max(kr) / kr[3]) ** gamma * dh.nanmedian(Skr)]
            print 'xx = ', xx
            print 'yy = ', yy
            ax.plot(xx, yy, 'k--', label=r'$S(k)\sim k^\gamma$')
            xx1 = [kr[3], np.max(kr)]
            yy1 = 0.001 * np.array([dh.nanmedian(Skr), (np.max(kr) / kr[3]) ** 2 * dh.nanmedian(Skr)])
            ax.plot(xx1, yy1, ':', color='#C0C0C0', label=r'$S(k)\sim k^2$')

            # Set ylim maximum
            maxval = max(np.max(np.array(yy1)), ymax)
            ax.set_ylim(ymax=10 * maxval)

            plt.legend(loc='center left', bbox_to_anchor=(1.1, 0.5))
            ax.set_ylabel(r'$S(k)$')
            ax.set_xlabel(r'wavenumber $k$')
            plt.suptitle(r'Calibration for $\gamma = $' + '{0:0.3f}'.format(gamma))
            plt.savefig(caloutdir + 'cal_gamma' + sf.float2pstr(gamma) + '.png', dpi=200)
            plt.close('all')

    if args.calibrate_kicksz_epsilon:
        import lepm.build.pointsets.gammakick_calibration as gammakick_calibration
        # To quantify the distance use the expectation of the log of zeta, as discussed here
        # http://stats.stackexchange.com/questions/121925/intuitive-descriptive-statistics-for-power-law-distributions
        gammav = np.arange(0.1, 2.1, 0.02)
        epsilonv = np.logspace(-18, 3, 66)
        nn = args.N
        gammakick_calibration.calibrate_kicksz_epsilon(gammav, epsilonv, nn, rootdir=args.rootdir)

    if args.calibrate_epsilon_kicksz:
        import lepm.build.pointsets.gammakick_calibration as gkc
        # Given gamma, given kicksz --> gives epsilon for transformation
        # Using the data from nn100000_ngammav100_nkickszv66, invert to find epsilon as a function of kicksz and gamma.
        # Choose a kick size, convert to epsilon, and test that choice of epsilon for the desired S(k) scaling as k->0,
        # for different values of gamma.
        seriesname = 'kicksz_epsilon/nn1000000_ngammav100_nkickszv66'
        datindir = args.rootdir + 'calibration_data/' + seriesname + '/'
        kickszv = np.arange(-18, 4, 2)
        gammav = np.arange(0.1, 2.1, 0.1)
        epsilons = np.zeros((len(kickszv), len(gammav)))
        colorv = lecmaps.husl_palette(len(gammav), h=0.02, l=0.5)
        ii = 0
        for gamma in gammav:
            jj = 0
            for kicksz in kickszv:
                epsilons[jj, ii] = gkc.retrieve_epsilon(kicksz, gamma, calibdata_dir=datindir)
                jj += 1
            plt.semilogy(kickszv, epsilons[:, ii], color=colorv[ii])
            ii += 1
        plt.show()

        # Retrieve epsilon, generate kicks, see if kicks have correct average log10(kicksz)
        fig, ax = leplt.initialize_1panel_fig(wsfrac=0.4, hsfrac=0.3, fontsize=18, vspace=20, x0frac=0.1)
        kickszv = np.arange(-3.0, 1.5, 1.)[::-1]
        colorv = lecmaps.husl_palette(len(kickszv))
        nn = 1e6
        ii = 0
        for kicksz in kickszv:
            jj = 0
            avglog = np.zeros(len(gammav), dtype=float)
            stdlog = np.zeros(len(gammav), dtype=float)
            for gamma in gammav:
                epsilon = gkc.retrieve_epsilon(kicksz, gamma, calibdata_dir=datindir)
                zeta = gammapowerlaw_random(gamma, epsilon, size=nn)
                avglog[jj] = np.sum(np.log10(zeta)) / float(nn)
                stdlog[jj] = np.sqrt(np.sum((np.log10(zeta) - avglog[ii]) ** 2) / float(nn))
                jj += 1

            plt.errorbar(gammav, avglog, yerr=stdlog, fmt='.', ecolor=colorv[ii], color=colorv[ii],
                         label=r'input $\langle \log_{10} \zeta \rangle = $' + '{0:0.2f}'.format(kicksz))
            ii += 1
        plt.legend(loc='center left', bbox_to_anchor=(1.05, 0.5))
        plt.suptitle(r'Measuring kick sizes using calibrated $\epsilon$, $N =$' + str(int(nn)))
        plt.savefig(args.rootdir + 'kicksz_vs_gamma_using_calibration_nn' + str(int(nn)) + '.png', dpi=300)

    if args.calibrate_Sk_kicksz:
        # Given kicksz, see if automatically generated epsilon has correct S(k) scaling
        """Calibrate S(k) scaling versus kicksz
        Example usage:
        python gammakick.py -N 300 -calibrate_Sk_kicksz
        """
        import lepm.structure as struct

        nksteps = 100
        klim_frac = 0.1
        LL = (float(nh), float(nv))
        print 'LL = ', LL
        gammav = np.arange(0.1, 2.1, 0.4)
        kickszv = np.arange(-3., 1., 0.25)
        colorv = lecmaps.husl_palette(len(kickszv))

        # Naming
        seriesname = 'structure_kicksz/nksteps{0:03d}'.format(nksteps) + '_sz{0:04d}'.format(nh) + \
                     '{0:04d}'.format(nv) + '_klim' + sf.float2pstr(klim_frac) + 'LL'
        caloutdir = args.rootdir + 'calibration/' + seriesname + '/'
        datoutdir = args.rootdir + 'calibration_data/' + seriesname + '/'
        dio.ensure_dir(caloutdir)
        dio.ensure_dir(datoutdir)

        # If on midway, use different path for calibration data
        calibdata_dir = args.rootdir + 'calibration_data/kicksz_epsilon/nn1000000_ngammav100_nkickszv66/'

        # Plot S(k) curves: for each kicksz, consider a series of exponents
        ii = 0
        for kicksz in kickszv:
            kk = 0
            ymax = 0.
            xmin = 1.
            fig, ax = leplt.initialize_1panel_fig(wsfrac=0.37, hsfrac=0.35, y0frac=0.14, x0frac=0.17)
            for gamma in gammav:
                fn = datoutdir + 'gamma' + sf.float2pstr(gamma) + \
                     '_kicksz{0:07.3f}'.format(kicksz).replace('-', 'n') + '.pkl'
                globfn = glob.glob(fn)
                print 'globfn = ', globfn
                if globfn:
                    with open(globfn[0], "r") as f:
                        datadict = pkl.load(f)
                    kr = datadict['kr']
                    Skr = datadict['Skr']
                else:
                    xy, eps = gammapts_kicksz(gamma, nh, nv, kicksz=kicksz, calibdata_dir=calibdata_dir)
                    kx, ky, Skmesh, kr, Skr = struct.calc_structure_factor(xy, LL, klim=klim_frac * LL[0],
                                                                           nksteps=nksteps)
                    datadict = {'kr': kr, 'Skr': Skr, 'eps': eps}
                    with open(fn, "w") as f:
                        pkl.dump(datadict, f)

                label = r'$\gamma=$' + '{0:0.02f}'.format(gamma) + r', $\epsilon=$' + '{0:0.0e}'.format(datadict['eps'])
                ax.loglog(kr, Skr, '.', color=colorv[kk], label=label, markersize=2)
                # Plot dashed line for desired scaling
                xx = [kr[3], np.max(kr)]
                yy = [np.nanmax(Skr) * (kr[3] / np.max(kr)) ** gamma, np.nanmax(Skr)]
                print 'xx = ', xx
                print 'yy = ', yy
                if kk == len(gammav) - 1:
                    ax.plot(xx, yy, 'k--', label=r'$S(k)\sim k^\gamma$')
                else:
                    ax.plot(xx, yy, 'k--')

                ymax = max(np.nanmax(Skr), ymax)
                xmin = min(kr[3], xmin)
                kk += 1

            xx1 = [kr[3], np.max(kr)]
            yy1 = 0.001 * np.array([dh.nanmedian(Skr), (np.max(kr) / kr[3]) ** 2 * dh.nanmedian(Skr)])
            ax.plot(xx1, yy1, ':', color='#C0C0C0', label=r'$S(k)\sim k^2$')

            # Set ylim maximum
            maxval = max(np.max(np.array(yy1)), ymax)
            ax.set_ylim(ymax=10 * maxval)
            ax.set_xlim(xmin=xmin)

            plt.legend(loc='center left', bbox_to_anchor=(1.1, 0.5))
            ax.set_ylabel(r'$S(k)$')
            ax.set_xlabel(r'wavenumber $k$')
            plt.suptitle(r'Calibration for $\langle \log_{10} \zeta \rangle = $' + '{0:00.3f}'.format(kicksz))
            plt.savefig(caloutdir +
                        'cal_kicksz{0:07.3f}'.format(kicksz).replace('.', 'p').replace('-', 'n') + '.png', dpi=200)
            plt.close('all')

    if args.calibration_check:
        import lepm.build.pointsets.gammakick_calibration as gkc
        calibdata_dir = args.rootdir + 'calibration_data/kicksz_epsilon/nn1000000_ngammav100_nkickszv66/'
        gammav = np.arange(0.1, 2.0, 0.3)
        fig, ax = leplt.initialize_1panel_fig(wsfrac=0.35, hsfrac=0.3, fontsize=18, vspace=20, x0frac=0.1)
        colorv = lecmaps.husl_palette(len(gammav)*2)

        kk = 0
        for gamma in gammav:
            eps = gkc.retrieve_epsilon(args.kicksz, gamma, calibdata_dir=calibdata_dir)
            zeta = gammapowerlaw_random(gamma, eps, size=5e5)
            vals, edges = np.histogram(np.log10(zeta), bins=10)
            # bins=np.logspace(np.log10(np.min(y)), np.log10(np.max(y)), 50))
            ax.loglog(edges[2:], vals[1:], '.', label=r'$\gamma = $' + '{0:0.2f}'.format(gamma) +
                                                      r', $\epsilon = $' + '{0:0.0e}'.format(eps), color=colorv[kk])
            # expected curve : (y1/x1^gamma) = (y0/x0^gamma)
            # xx = 0.1 * edges[2:]
            # yy = vals[1] * (xx / xx[0]) ** (-1 - gamma)
            # ax.plot(xx, yy, 'k--')
            ax.legend(loc='center left', bbox_to_anchor=(1.0, 0.5))
            ax.set_ylim(ymin=0.8)
            kk += 1
        plt.suptitle('PDFs with constant kick size: ' + r'$\langle \log_{10} \zeta \rangle = $' +
                     '{0:0.3f}'.format(args.kicksz) +
                     '\n' + r'$x \rightarrow \epsilon x^{\frac{1}{-1-\gamma}}(1-x)$')
        plt.savefig(args.rootdir + 'gamma_pdfs_constkicksz.png', dpi=300)
        plt.clf()

        fig, ax = leplt.initialize_1panel_fig(wsfrac=0.35, hsfrac=0.3, fontsize=18, vspace=20, x0frac=0.1)
        kk = 0
        for gamma in gammav:
            eps = gkc.retrieve_epsilon(args.kicksz, gamma, calibdata_dir=calibdata_dir)
            zeta = gammapowerlaw_random(gamma, eps, size=5e5)
            vals, edges = np.histogram(np.log10(zeta), bins=10)
            # bins=np.logspace(np.log10(np.min(y)), np.log10(np.max(y)), 50))
            ax.loglog(edges[2:], vals[1:], '.', label=r'$\gamma = $' + '{0:0.2f}'.format(gamma) +
                                                      r', $\epsilon = $' + '{0:0.0e}'.format(eps), color=colorv[kk])
            # expected curve : (y1/x1^gamma) = (y0/x0^gamma)
            # xx = 0.1 * edges[2:]
            # yy = vals[1] * (xx / xx[0]) ** (-1 - gamma)
            # ax.plot(xx, yy, 'k--')
            ax.legend(loc='center left', bbox_to_anchor=(1.0, 0.5))
            ax.set_ylim(ymin=0.8)
            kk += 1
        plt.suptitle('PDFs with constant kick size: ' + r'$\langle \log_{10} \zeta \rangle = $' +
                     '{0:0.3f}'.format(args.kicksz) +
                     '\n' + r'$x \rightarrow \epsilon x^{\frac{1}{-1-\gamma}}(1-x)$')
        plt.savefig(args.rootdir + 'gamma_pdfs_constkicksz.png', dpi=300)
        plt.clf()

    if args.make_pointset:
        '''Create and save hyperuniform point set
        
        Example usage:
        python gammakick.py -make_pointset -gamma 0.50 -conf 1:20 -N 12
        python ./build/pointsets/gammakick.py -make_pointset -gamma 1.60 -conf 1 -NH 80 -NV 120 -save_im
        python ./build/pointsets/gammakick.py -make_pointset -gamma 1.60 -conf 1 -NH 80 -NV 120 -save_im -dt 0.01
        python ./build/pointsets/gammakick.py -make_pointset -gamma 1.60 -conf 1 -NH 12 -NV 10 -save_im
        '''
        import socket
        nn = nh * nv
        rootdir = args.rootdir

        # If on midway, use different path for calibration data
        calibdata_dir = args.rootdir + 'calibration_data/kicksz_epsilon/nn1000000_ngammav100_nkickszv66/'
        if socket.gethostname()[0:6] == 'midway':
            print 'calibdata is ', calibdata_dir
            calibdata_dir = calibdata_dir.replace('/Users/npmitchell/Dropbox/Soft_Matter/GPU/networks/' +
                                                  'random_organization_source/', '/home/npmitchell/scratch-midway/')
            rootdir = rootdir.replace('/Users/npmitchell/Dropbox/Soft_Matter/GPU/networks/random_organization_source/',
                                      '/home/npmitchell/scratch-midway/')

        for conf in sf.string_sequence_to_numpy_array(args.conf, dtype=int):
            outdir = rootdir + 'gamma' + sf.float2pstr(args.gamma) + '/' + \
                     'L' + str(int(nn)) + '_nh' + str(int(nh)) + '_nv' + str(int(nv)) + \
                     '_kicksz' + sf.float2pstr(args.kicksz, ndigits=5) + '/' + \
                     'd{0:02d}'.format(conf) + '/' + \
                     'gamma_kick_ts{0:05d}'.format(args.timesteps) + '_dt' + sf.float2pstr(args.dt, ndigits=4) + '/'
            dio.ensure_dir(outdir)
            outpath = outdir + 'gammakickspreadxy_t'
            xy, eps = gammapts_kicksz(args.gamma, nh, nv, kicksz=args.kicksz, calibdata_dir=calibdata_dir)
            xy -= np.array([nh * 0.5, nv * 0.5])
            pv = np.array([[nh, 0], [0, nv]])
            bbox = 0.5 * np.array([[-nh, nv], [nh, nv], [nh, -nv], [-nh, -nv]])
            xyout = relax.relax_overdamped(xy, pv, bbox, args.timesteps, args.dt, modout=10, outpath=outpath,
                                           save_im=args.save_im)

    if args.make_pointset_bounded:
        """Create and save hyperuniform point set with bounded amplitude kicks (NOT STANDARD)                        
        """
        nn = nh * nv
        bb = np.min(nh, nv)
        rootdir = '/Users/npmitchell/Dropbox/Soft_Matter/GPU/networks/random_organization_source/random_kick_gamma_npm/'
        for conf in sf.string_sequence_to_numpy_array(args.conf, dtype=int):
            outdir = rootdir + 'gamma' + sf.float2pstr(args.gamma) + '/' + \
                     'L{0:06d}'.format(nn) + '_aa' + sf.float2pstr(args.aa, ndigits=5) +\
                     '_bb' + sf.float2pstr(bb, ndigits=2) + '/' + \
                     'd{0:02d}'.format(conf) + '/' + \
                     'gamma_kick_ts{0:05d}'.format(args.timesteps) + '_dt' + sf.float2pstr(args.dt, ndigits=4) + '/'
            dio.ensure_dir(outdir)
            outpath = outdir + 'gammakickspreadxy_t'
            xy = gammapts_boundedkick(args.gamma, nh, nv, aa=args.aa, bb=bb)
            xy -= np.array([nh * 0.5, nv * 0.5])
            pv = np.array([[nh, 0], [0, nv]])
            bbox = 0.5 * np.array([[-nh, nv], [nh, nv], [nh, -nv], [-nh, -nv]])
            xyout = relax.relax_overdamped(xy, pv, bbox, args.timesteps, args.dt, modout=10, outpath=outpath,
                                           save_im=True)

