import numpy as np
import lepm.build.build_lattice_functions as blf
import lepm.lattice_elasticity as le
import lepm.le_geometry as leg
import lepm.stringformat as sf
import lepm.line_segments as linsegs
import matplotlib.pyplot as plt
from lepm.build import build_jammed
import lepm.data_handling as dh

'''Functions for creating networks from jammed (here 'isostatic') lattices, voronoized by a centroidal construction'''


def build_iscentroid(lp):
    """Build centroidal (honeycomb-like) network from isostatic point set generated by Daniel Hexner.

    """
    NH = lp['NH']
    NV = lp['NV']
    # First check that if periodic, NP_load is defined as nonzero
    if lp['periodicBC']:
        if lp['NP_load'] == 0:
            RuntimeError('For iscentroid lattices, if periodicBC, then must specify NP_load instead of NH, NV.')

    use_hexner = (lp['source'] == 'hexner')
    if use_hexner:
        # Use Daniel Hexner's lattices
        points, BL, LLv, numberstr, sizestr, lp = build_jammed.load_hexner_jammed(lp, BL_load=False)
        LL = (LLv, LLv)
    else:
        # Use Stephan Ulrich's lattices
        if lp['periodicBC']:
            RuntimeError('Not sure if Stephan Ulrich lattices are periodic!')
        number = '{0:03d}'.format(int(lp['loadlattice_number']))
        zindex = '{0:03d}'.format(int(lp['loadlattice_z']))
        points = np.loadtxt(lp['rootdir'] + 'networks/' +
                            'isostatic_source/isostatic_homog_z'+zindex+'_conf'+number+'_nodes.txt')
        LL = (NH, NV)

    points -= np.mean(points, axis=0)

    # Do initial (generous) cropping if not using entire lattice
    if lp['NP_load'] == 0:
        if lp['check']:
            plt.plot(points[:, 0], points[:, 1], 'b.')
            plt.title('Point set before initial cutting')
            plt.show()
        xytmp, trash1, trash2, trash3 = \
            blf.mask_with_polygon(lp['shape'], NH * 2. + 5, NV * 2. + 5, points, [], eps=0.00)
        polygon = blf.auto_polygon(lp['shape'], NH, NV, eps=0.00)
        if lp['check']:
            plt.plot(xytmp[:, 0], xytmp[:, 1], 'b.')
            plt.title('Point set after initial cutting')
            plt.show()
        xy, NL, KL, BL = le.delaunay_centroid_lattice_from_pts(xytmp, polygon=polygon, trimbound=False,
                                                               check=lp['check'])
        LL = (np.max(xy[:, 0]) - np.min(xy[:, 0]), np.max(xy[:, 1]) - np.min(xy[:, 1]))
        PVxydict = {}
        PVx = []
        PVy = []
        periodicBCstr = ''
    else:
        polygon = 0.5 * np.array([[-LL[0], -LL[1]], [LL[0], -LL[1]], [LL[0], LL[1]], [-LL[0], LL[1]]])
        xy, NL, KL, BL, PVxydict = le.delaunay_centroid_rect_periodic_network_from_pts(points, LL, BBox='auto',
                                                                                       check=lp['check'])
        PVx, PVy = le.PVxydict2PVxPVy(PVxydict, NL)
        periodicBCstr = '_periodic'
    if lp['check']:
        plt.plot(xy[:, 0], xy[:, 1], 'b.')
        plt.title('Point set after decoration and cropping')
        plt.show()

    # Rescale so that median bond length is unity
    bL = le.bond_length_list(xy, BL, NL=NL, KL=KL, PVx=PVx, PVy=PVy)
    scale = 1. / np.median(bL)
    xy *= scale
    polygon *= scale
    LL = (LL[0]*scale, LL[1]*scale)
    if lp['NP_load'] != 0:
        PVx *= scale
        PVy *= scale
        PVxydict.update((key, val * scale) for key, val in PVxydict.items())

    if use_hexner:
        lattice_exten = 'iscentroid_' + lp['shape'] + periodicBCstr + '_hexner_size' + sizestr + '_conf' + numberstr
    else:
        lattice_exten = 'iscentroid_' + lp['shape'] + periodicBCstr + '_homog_zindex' + zindex + '_conf' + number[1:]
    BBox = polygon
    LV = 'none'
    LVUC = 'none'
    UC = 'none'
    return xy, NL, KL, BL, PVx, PVy, PVxydict, LVUC, BBox, LL, LV, UC, lattice_exten


def build_kagome_isocent(lp):
    """

    Parameters
    ----------
    lp

    Returns
    -------

    """
    shape = lp['shape']
    check = lp['check']
    NH = lp['NH']
    NV = lp['NV']
    print('Loading isostatic to build kagome-decorated lattice...')
    import lepm.build.build_jammed as build_jammed
    use_hexner = (lp['source'] == 'hexner')
    if use_hexner:
        # Use Daniel Hexner's lattices
        points, BL, LLv, numberstr, sizestr, lp = build_jammed.load_hexner_jammed(lp, BL_load=False)
        LL = (LLv, LLv)
    else:
        number = '{0:03d}'.format(int(lp['loadlattice_number']))
        zindex = '{0:03d}'.format(int(lp['loadlattice_z']))
        points = np.loadtxt(lp['rootdir'] + 'networks/' +
                            'isostatic_source/isostatic_homog_z' + zindex + '_conf' + number + '_nodes.txt')
        # LL = NH

    points -= np.mean(points, axis=0)

    # Separate procedure if not using entire lattice
    if lp['NP_load'] == 0:
        # Do initial (generous) cropping if not using entire lattice
        if check:
            plt.plot(points[:, 0], points[:, 1], 'b.')
            plt.title('Point set before initial cutting')
            plt.show()
        xytmp, trash1, trash2, trash3 = blf.mask_with_polygon(shape, NH * 1.2 + 8, NV * 1.2 + 8, points, [], eps=0.)
        polygon = blf.auto_polygon(shape, NH, NV, eps=0.00)
        if check:
            plt.plot(xytmp[:, 0], xytmp[:, 1], 'b.')
            plt.title('Point set after initial cutting')
            plt.show()

        xy, NL, KL, BL = blf.kagomecentroid_lattice_from_pts(xytmp, polygon=polygon, trimbound=False, thres=2.0,
                                                             check=lp['check'])
        LL = (np.max(xy[:, 0]) - np.min(xy[:, 0]), np.max(xy[:, 1]) - np.min(xy[:, 1]))
        PVxydict = {}
        PVx = []
        PVy = []
        periodicBCstr = ''
    else:
        polygon = 0.5 * np.array([[-LL[0], -LL[1]], [LL[0], -LL[1]], [LL[0], LL[1]], [-LL[0], LL[1]]])
        xy, NL, KL, BL, PVxydict = blf.kagomecentroid_periodic_network_from_pts(points, LL, BBox='auto',
                                                                                check=lp['check'])
        PVx, PVy = le.PVxydict2PVxPVy(PVxydict, NL)
        periodicBCstr = '_periodic'

    if check:
        plt.plot(xy[:, 0], xy[:, 1], 'b.')
        plt.title('Point set after decoration and cropping')
        plt.show()

    # Rescale so that median bond length is unity
    bL = le.bond_length_list(xy, BL, NL=NL, KL=KL, PVx=PVx, PVy=PVy)
    scale = 1. / np.median(bL)
    xy *= scale
    polygon *= scale
    LL = (LL[0] * scale, LL[1] * scale)
    if lp['NP_load'] != 0:
        PVx *= scale
        PVy *= scale
        PVxydict.update((key, val * scale) for key, val in PVxydict.items())

    if use_hexner:
        lattice_exten = 'kagome_isocent_' + shape + periodicBCstr + '_hexner_size' + sizestr + '_conf' + numberstr
    else:
        lattice_exten = 'kagome_isocent_' + shape + periodicBCstr + '_ulrich_homog_zindex' + zindex +\
                        '_conf' + number[1:]
    BBox = polygon
    LV = 'none'
    UC = 'none'
    LVUC = 'none'
    return xy, NL, KL, BL, PVx, PVy, PVxydict, LVUC, BBox, LL, LV, UC, lattice_exten


def build_accordionkag_isocent(lp):
    """Create an accordion-bonded kagomized amorphous network from a loaded jammed point set.

    Parameters
    ----------
    lp

    Returns
    -------

    """
    shape = lp['shape']
    check = lp['check']
    NH = lp['NH']
    NV = lp['NV']
    print('Loading isostatic to build kagome-decorated lattice...')
    import lepm.build.build_jammed as build_jammed
    use_hexner = (lp['source'] == 'hexner')
    if use_hexner:
        # Use Daniel Hexner's lattices
        points, BL, LLv, numberstr, sizestr, lp = build_jammed.load_hexner_jammed(lp, BL_load=False)
        LL = (LLv, LLv)
    else:
        number = '{0:03d}'.format(int(lp['loadlattice_number']))
        zindex = '{0:03d}'.format(int(lp['loadlattice_z']))
        points = np.loadtxt(lp['rootdir'] + 'networks/' +
                            'isostatic_source/isostatic_homog_z' + zindex + '_conf' + number + '_nodes.txt')
        # LL = NH

    points -= np.mean(points, axis=0)

    # Separate procedure if not using entire lattice
    if lp['NP_load'] == 0:
        # Do initial (generous) cropping if not using entire lattice
        if check:
            plt.plot(points[:, 0], points[:, 1], 'b.')
            plt.title('Point set before initial cutting')
            plt.show()
        xytmp, trash1, trash2, trash3 = blf.mask_with_polygon(shape, NH * 1.2 + 8, NV * 1.2 + 8, points, [], eps=0.)
        polygon = blf.auto_polygon(shape, NH, NV, eps=0.00)
        if check:
            plt.plot(xytmp[:, 0], xytmp[:, 1], 'b.')
            plt.title('Point set after initial cutting')
            plt.show()

        xy, NL, KL, BL = le.delaunay_centroid_lattice_from_pts(xytmp, polygon=polygon, trimbound=False,
                                                               check=lp['check'])

        #################################################################
        # nzag controlled by lp['intparam'] below
        xyacc, BLacc, LVUC, UC, xyvertices, lattice_exten_add = \
            blf.accordionize_network(xy, BL, lp, PVxydict=None, PVx=None, PVy=None, PV=None)

        print 'BL = ', BL

        # need indices of xy that correspond to xyvertices
        # note that xyvertices gives the positions of the vertices, not their indices
        inRx = np.in1d(xyacc[:, 0], xyvertices[:, 0])
        inRy = np.in1d(xyacc[:, 1], xyvertices[:, 1])
        vxind = np.where(np.logical_and(inRx, inRy))[0]
        print 'vxind = ', vxind

        # Note: beware, do not provide NL and KL to decorate_bondneighbors_elements() since NL,KL need
        # to be recalculated
        xy, BL = blf.decorate_bondneighbors_elements(xyacc, BLacc, vxind, PVxydict=None, viewmethod=False,
                                                     check=lp['check'])
        NL, KL = le.BL2NLandKL(BL, NP=len(xy))

        #################################################################

        LL = (np.max(xy[:, 0]) - np.min(xy[:, 0]), np.max(xy[:, 1]) - np.min(xy[:, 1]))
        PVxydict = {}
        PVx = []
        PVy = []
        periodicBCstr = ''
    else:
        polygon = 0.5 * np.array([[-LL[0], -LL[1]], [LL[0], -LL[1]], [LL[0], LL[1]], [-LL[0], LL[1]]])
        xy, NL, KL, BL, PVxydict = blf.kagomecentroid_periodic_network_from_pts(points, LL, BBox='auto',
                                                                                check=lp['check'])
        PVx, PVy = le.PVxydict2PVxPVy(PVxydict, NL)
        periodicBCstr = '_periodic'

    # Rescale so that median bond length is unity
    bL = le.bond_length_list(xy, BL, NL=NL, KL=KL, PVx=PVx, PVy=PVy)
    scale = 1. / np.median(bL)
    xy *= scale
    polygon *= scale
    LL = (LL[0] * scale, LL[1] * scale)
    if lp['periodicBC']:
        PVx *= scale
        PVy *= scale
        PVxydict.update((key, val * scale) for key, val in PVxydict.items())

    lattice_exten = 'accordionkag_isocent_' + shape + periodicBCstr + '_d{0:02d}'.format(int(lp['conf'])) + \
                    lattice_exten_add

    if use_hexner:
        lattice_exten = 'accordionkag_isocent_' + shape + periodicBCstr + '_hexner_size' + sizestr + '_conf' + \
                        numberstr + lattice_exten_add
    else:
        lattice_exten = 'accordionkag_isocent_' + shape + periodicBCstr + '_ulrich_homog_zindex' + zindex + \
                        lattice_exten_add
    LV = 'none'
    LVUC = 'none'
    UC = 'none'
    BBox = polygon
    return xy, NL, KL, BL, PVxydict, PVx, PVy, LL, LVUC, LV, UC, BBox, lattice_exten
